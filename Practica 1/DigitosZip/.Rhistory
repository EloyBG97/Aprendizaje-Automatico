m
simula_unif = function (N=2,dims=2, rango = c(0,1)){
m = matrix(runif(N*dims, min=rango[1], max=rango[2]),
nrow = N, ncol=dims, byrow=T)
m
}
setwd("./datos")  #directorio de trabajo
setwd("/home/eloybg/Escritorio/UGR/3º Carrera/2ºCuatrimestre (CSI)/Aprendizaje Automatico/Practicas/Aprendizaje-Automatico/Practica 1/DigitosZip")  #directorio de trabajo
# ------------------------------------------------------------------------
digit.train <- read.table("zip.train",
quote="\"", comment.char="", stringsAsFactors=FALSE)
setwd("/home/eloybg/Escritorio/UGR/3º Carrera/2ºCuatrimestre (CSI)/Aprendizaje Automatico/Practicas/Aprendizaje-Automatico/Practica 1/DigitosZip")  #directorio de trabajo
# ------------------------------------------------------------------------
digit.train <- read.table("zip.train",
quote="\"", comment.char="", stringsAsFactors=FALSE)
grises
# ------------------------------------------------------------------------
digit.train <- read.table("zip.train",
quote="\"", comment.char="", stringsAsFactors=FALSE)
digitos15.train = digit.train[digit.train$V1==1 | digit.train$V1==5,]
digitos = digitos15.train[,1]    # vector de etiquetas del train
ndigitos = nrow(digitos15.train)  # numero de muestras del train
# se retira la clase y se monta una matriz 3D: 599*16*16
grises = array(unlist(subset(digitos15.train,select=-V1)),c(ndigitos,16,16))
rm(digit.train)
rm(digitos15.train)
par(mfrow=c(2,2))
grises
dim(grises)
intensidad = apply(grises,1,mean)
intensidad
simetria <- apply(grises,1,f_simetria)
## ------------------------------------------------------------------------
fsimetria <- function(A){
A = abs(A-A[,ncol(A):1])
-sum(A)
}
simetria <- apply(grises,1,fsimetria)
simetria
datostr = as.matrix(cbind(intensidad,simetria))
digitos
etiquetas = digitos
etiquetas[etiquetas == 5] = -1
datostr
grises
plot(datostr)
plot(datostr[1:20,])
plot(datostr[1:100,])
plot(datostr[1:200,])
plot(datostr[1:300,])
plot(datostr[1:400,])
plot(datostr[1:500,])
plot(datostr[1:599,])
plot(datostr)
plot(datostr, col = 0 + datostr[,1])
plot(datostr, col = 0.5 + datostr[,1])
plot(datostr, col = 1 + datostr[,1])
plot(datostr, col = 1 + datostr[,1])
plot(datostr, col = 1 + datostr[,3])
plot(datostr, col = 1 + datostr[,2])
plot(datostr, col = 1 + datostr[,1])
plot(datostr, col = 1 + datostr[2,1])
plot(datostr)
?plot
setwd("/home/eloybg/Escritorio/UGR/3º Carrera/2ºCuatrimestre (CSI)/Aprendizaje Automatico/Practicas/Aprendizaje-Automatico/Practica 1/DigitosZip")  #directorio de trabajo
# ------------------------------------------------------------------------
digit.train <- read.table("zip.train",
quote="\"", comment.char="", stringsAsFactors=FALSE)
digitos15.train = digit.train[digit.train$V1==1 | digit.train$V1==5,]
digitos = digitos15.train[,1]    # vector de etiquetas del train
ndigitos = nrow(digitos15.train)  # numero de muestras del train
# se retira la clase y se monta una matriz 3D: 599*16*16
grises = array(unlist(subset(digitos15.train,select=-V1)),c(ndigitos,16,16))
rm(digit.train)
rm(digitos15.train)
par(mfrow=c(2,2))
for(i in 1:4){
imagen = grises[i,,16:1] # se rota para verlo bien
image(z=imagen)
}
digitos[1:4] # etiquetas correspondientes a las 4 imágenes
## ------------------------------------------------------------------------
fsimetria <- function(A){
A = abs(A-A[,ncol(A):1])
-sum(A)
}
pasoARecta= function(w){
if(length(w)!= 3)
stop("Solo tiene sentido con 3 pesos")
a = -w[1]/w[2]
b = -w[3]/w[2]
c(a,b)
}
set.seed(3)	# se establece la semilla
simula_unif = function (N=2,dims=2, rango = c(0,1)){
m = matrix(runif(N*dims, min=rango[1], max=rango[2]),
nrow = N, ncol=dims, byrow=T)
m
}
simula_gaus = function(N=2,dim=2,sigma){
if (missing(sigma)) stop("Debe dar un vector de varianzas")
sigma = sqrt(sigma)  # para la generación se usa sd, y no la varianza
if(dim != length(sigma)) stop ("El numero de varianzas es distinto de la dimensión")
simula_gauss1 = function() rnorm(dim, sd = sigma) # genera 1 muestra, con las desviaciones especificadas
m = t(replicate(N,simula_gauss1())) # repite N veces, simula_gauss1 y se hace la traspuesta
m
}
simula_recta = function (intervalo = c(-1,1), visible=F){
ptos = simula_unif(2,2,intervalo) # se generan 2 puntos
a = (ptos[1,2] - ptos[2,2]) / (ptos[1,1]-ptos[2,1]) # calculo de la pendiente
b = ptos[1,2]-a*ptos[1,1]  # calculo del punto de corte
if (visible) {  # pinta la recta y los 2 puntos
if (dev.cur()==1) # no esta abierto el dispositivo lo abre con plot
plot(1, type="n", xlim=intervalo, ylim=intervalo)
points(ptos,col=3)  #pinta en verde los puntos
abline(b,a,col=3)   # y la recta
}
c(a,b) # devuelve el par pendiente y punto de corte
}
pintar_frontera = function(f,rango=c(-50,50)) {
x=y=seq(rango[1],rango[2],length.out = 500)
z = outer(x,y,FUN=f)
if (dev.cur()==1) # no esta abierto el dispositivo lo abre con plot
plot(1, type="n", xlim=rango, ylim=rango)
contour(x,y,z, levels = 1:20, xlim =rango, ylim=rango, xlab = "x", ylab = "y")
}
print ("Pulsa RETORNO")
scan(n=1)
result <- data * sample(c(1, -1), size=length(label), replace=TRUE, prob=c(1 - p, p))
result
}
print ("Pulsa RETORNO")
noise <- function(label, p){
result <- data * sample(c(1, -1), size=length(label), replace=TRUE, prob=c(1 - p, p))
result
}
install.packages("rmarkdown")
library("rmarkdown", lib.loc="~/R/x86_64-pc-linux-gnu-library/3.4")
?expression()
f = expresion(2*x)
f = expression(2*x)
eval(f)
eval(f,8)
eval(8,f)
f = expression(x,2*x)
eval(8,f)
eval(f,8)
eval(8,f)
f = expression(1:2 + 1:2)
eval(f)
eval(f)
f = expression(1:3 + 1:3)
eval(f)
x <- 0:15
y <- 0:15
z <- x*y
plot(z,x,y)
plot(z,x)
plot(z)
plot(z)
plot(z)
plot(z)
plot(z)
plot(z)
plot(z)
?plot
image(z,x,y)
contour(z,x,y)
contour(z)
x <- rep(0,4)
x
?eval
?expression()
?enexpr
?substitute
expr <- expression((2*x))
substitute(expr, x=0)
substitute(expr, 0)
substitute(expr, list(x = 1))
substitute(expr, list(x = 1))
eval(expr)
eval(expr)
substitute(expr, list(x = 2))
eval(expr)
expr <- expression((2*y))
eval(expr)
eval(expr)
eval(expr)
expr <- expression((2*j))
eval(expr)
substitute(expr, list(j = 2))
eval(expr)
e
pi
fu(1,1)
fu <- function(u,v) {2*((u**3) * 2.71**(v-2) - 4*(v**3)*2.71**-u)*(3*u*2.71**(v-2) + 4 * (v**3) * e**-u)}
fu(1,1)
fu <- function(u,v) {2*((u**3) * 2.71**(v-2) - 4*(v**3)*2.71**-u)*(3*u*2.71**(v-2) + 4 * (v**3) * 2.71**-u)}
fu(1,1)
fu(1,1)
fu(1,1)
fu(1,1)
fu(1,1)
fu(1,1)
fu(1,1)
BatchGradientDescent = function( u, v, mu, epsilon) {
x <- 0
y <- 0
#Funcion que queremos minimizar
f <- expression(( (u ** 3) * (2.71 ** (v - 2) )  - 4 * (v ** 3) * 2.71 ** -u ) ** 2 )
#Derivada parcial con respecto a u
fu <- expression( { 2 * ( (u ** 3) * (2.71 ** (v - 2) )  - 4 * (v ** 3) * 2.71 ** -u ) * (3 * u * 2.71 ** (v - 2) + 4 * (v ** 3) * 2.71 ** -u ) )
#Derivada parcial con respecto a v
fv <- expression( 2 * ( (u ** 3) * (2.71 ** (v - 2) )  - 4 * (v ** 3) * 2.71 ** -u ) * ( (u ** 3) * (2.71 ** (v - 2) ) - 12 * (v ** 2) * e ** - u) )
while(eval(f) > epsilon) {
x <- u - eval(fu)
y <- v - eval(fv)
u <- x
v <- y
}
c(u,v)
}
BatchGradientDescent = function( u, v, mu, epsilon) {
x <- 0
y <- 0
#Funcion que queremos minimizar
f <- expression(( (u ** 3) * (2.71 ** (v - 2) )  - 4 * (v ** 3) * 2.71 ** -u ) ** 2 )
#Derivada parcial con respecto a u
fu <- expression( 2 * ( (u ** 3) * (2.71 ** (v - 2) )  - 4 * (v ** 3) * 2.71 ** -u ) * (3 * u * 2.71 ** (v - 2) + 4 * (v ** 3) * 2.71 ** -u ) )
#Derivada parcial con respecto a v
fv <- expression( 2 * ( (u ** 3) * (2.71 ** (v - 2) )  - 4 * (v ** 3) * 2.71 ** -u ) * ( (u ** 3) * (2.71 ** (v - 2) ) - 12 * (v ** 2) * e ** - u) )
while(eval(f) > epsilon) {
x <- u - eval(fu)
y <- v - eval(fv)
u <- x
v <- y
}
c(u,v)
}
BatchGradientDescent(1,1,)
BatchGradientDescent = function( u, v, mu, epsilon) {
x <- 0
y <- 0
#Funcion que queremos minimizar
f <- expression(( (u ** 3) * (2.71 ** (v - 2) )  - 4 * (v ** 3) * 2.71 ** -u ) ** 2 )
#Derivada parcial con respecto a u
fu <- expression( 2 * ( (u ** 3) * (2.71 ** (v - 2) )  - 4 * (v ** 3) * 2.71 ** -u ) * (3 * u * 2.71 ** (v - 2) + 4 * (v ** 3) * 2.71 ** -u ) )
#Derivada parcial con respecto a v
fv <- expression( 2 * ( (u ** 3) * (2.71 ** (v - 2) )  - 4 * (v ** 3) * 2.71 ** -u ) * ( (u ** 3) * (2.71 ** (v - 2) ) - 12 * (v ** 2) * e ** - u) )
while(eval(f) > epsilon) {
x <- u - mu * eval(fu)
y <- v - mu * eval(fv)
u <- x
v <- y
}
c(u,v)
}
BatchGradientDescent(1,1,0.1,10**-14)
BatchGradientDescent = function( u, v, mu, epsilon) {
x <- 0
y <- 0
#Funcion que queremos minimizar
f <- expression(( (u ** 3) * (2.71 ** (v - 2) )  - 4 * (v ** 3) * 2.71 ** -u ) ** 2 )
#Derivada parcial con respecto a u
fu <- expression( 2 * ( (u ** 3) * (2.71 ** (v - 2) )  - 4 * (v ** 3) * 2.71 ** -u ) * (3 * u * 2.71 ** (v - 2) + 4 * (v ** 3) * 2.71 ** -u ) )
#Derivada parcial con respecto a v
fv <- expression( 2 * ( (u ** 3) * (2.71 ** (v - 2) )  - 4 * (v ** 3) * 2.71 ** -u ) * ( (u ** 3) * (2.71 ** (v - 2) ) - 12 * (v ** 2) * 2.71 ** - u) )
while(eval(f) > epsilon) {
x <- u - mu * eval(fu)
y <- v - mu * eval(fv)
u <- x
v <- y
}
c(u,v)
}
BatchGradientDescent(1,1,0.1,10**-14)
?print
BatchGradientDescent = function( u, v, mu, epsilon) {
x <- 0
y <- 0
#Funcion que queremos minimizar
f <- expression(( (u ** 3) * (2.71 ** (v - 2) )  - 4 * (v ** 3) * 2.71 ** -u ) ** 2 )
#Derivada parcial con respecto a u
fu <- expression( 2 * ( (u ** 3) * (2.71 ** (v - 2) )  - 4 * (v ** 3) * 2.71 ** -u ) * (3 * u * 2.71 ** (v - 2) + 4 * (v ** 3) * 2.71 ** -u ) )
#Derivada parcial con respecto a v
fv <- expression( 2 * ( (u ** 3) * (2.71 ** (v - 2) )  - 4 * (v ** 3) * 2.71 ** -u ) * ( (u ** 3) * (2.71 ** (v - 2) ) - 12 * (v ** 2) * 2.71 ** - u) )
while(eval(f) > epsilon) {
x <- u - mu * eval(fu)
y <- v - mu * eval(fv)
u <- x
v <- y
print("u: ",u," v: ",v,"f(u,v) = ",eval(f))
}
c(u,v)
}
BatchGradientDescent(1,1,0.1,10**-14)
BatchGradientDescent = function( u, v, mu, epsilon) {
x <- 0
y <- 0
#Funcion que queremos minimizar
f <- expression(( (u ** 3) * (2.71 ** (v - 2) )  - 4 * (v ** 3) * 2.71 ** -u ) ** 2 )
#Derivada parcial con respecto a u
fu <- expression( 2 * ( (u ** 3) * (2.71 ** (v - 2) )  - 4 * (v ** 3) * 2.71 ** -u ) * (3 * u * 2.71 ** (v - 2) + 4 * (v ** 3) * 2.71 ** -u ) )
#Derivada parcial con respecto a v
fv <- expression( 2 * ( (u ** 3) * (2.71 ** (v - 2) )  - 4 * (v ** 3) * 2.71 ** -u ) * ( (u ** 3) * (2.71 ** (v - 2) ) - 12 * (v ** 2) * 2.71 ** - u) )
while(eval(f) > epsilon) {
x <- u - mu * eval(fu)
y <- v - mu * eval(fv)
u <- x
v <- y
print(eval(f))
}
c(u,v)
}
BatchGradientDescent(1,1,0.1,10**-14)
BatchGradientDescent = function( u, v, mu, epsilon) {
x <- 0
y <- 0
iterate <- 0
#Funcion que queremos minimizar
f <- expression(( (u ** 3) * (2.71 ** (v - 2) )  - 4 * (v ** 3) * 2.71 ** -u ) ** 2 )
#Derivada parcial con respecto a u
fu <- expression( 2 * ( (u ** 3) * (2.71 ** (v - 2) )  - 4 * (v ** 3) * 2.71 ** -u ) * (3 * u * 2.71 ** (v - 2) + 4 * (v ** 3) * 2.71 ** -u ) )
#Derivada parcial con respecto a v
fv <- expression( 2 * ( (u ** 3) * (2.71 ** (v - 2) )  - 4 * (v ** 3) * 2.71 ** -u ) * ( (u ** 3) * (2.71 ** (v - 2) ) - 12 * (v ** 2) * 2.71 ** - u) )
while(eval(f) > epsilon) {
x <- u - mu * eval(fu)
y <- v - mu * eval(fv)
u <- x
v <- y
iterate <- iterate + 1
}
print(iterate)
print(eval(f))
c(u,v)
}
BatchGradientDescent(1,1,0.1,10**-14)
BatchGradientDescent(1,1,0.1,10**-14)
BatchGradientDescent(1,1,0.1,10**-14)
View(BatchGradientDescent)
View(BatchGradientDescent)
x <- 0
cat("Hola: ",x)
cat(\nHola)
cat(Hola)
cat("\nHola")
cat("H\nHola")
cat("H\n\tHola")
f <- expression(( (u ** 3) * (2.71 ** (v - 2) )  - 4 * (v ** 3) * 2.71 ** -u ) ** 2 )
x <- 0:100
y <- 0:100
u <- 0:100
v <- 0:100
z <- eval(f)
z
persp(u,v,z)
f <- function(x,y) {( (u ** 3) * (2.71 ** (v - 2) )  - 4 * (v ** 3) * 2.71 ** -u ) ** 2}
x <- 0:100
y <- 0:100
z <- outer(x,y,f)
f <- function(u,v) {( (u ** 3) * (2.71 ** (v - 2) )  - 4 * (v ** 3) * 2.71 ** -u ) ** 2}
z <- outer(x,y,f)
persp((x,y,z))
persp(x,y,z)
persp(x,y,z,theta = 30)
persp(x,y,z,theta = 30, phi = 30)
persp(x,y,z,theta = 30, phi = -30)
persp(x,y,z,theta = 30, phi = -30, col="orange")
persp(x,y,z,theta = 30, phi = -30, col="orange")
persp(x,y,z,theta = 30, phi = -10, col="orange")
persp(x,y,z,theta = 30, phi = -10, col="red")
x <- 0:50
y <- 0:50
z <- outer(x,y,f)
persp(x,y,z,theta = 30, phi = -10, col="orange")
persp(x,y,z,theta = 30, phi = 10, col="orange")
persp(x,y,z,theta = 90, phi = 10, col="orange")
persp(x,y,z,theta = 50, phi = 10, col="orange")
persp(x,y,z,theta = -50, phi = 10, col="orange")
persp(x,y,z,theta = -45, phi = 10, col="orange")
persp(x,y,z,theta = -20, phi = 10, col="orange")
persp(x,y,z,theta = -90, phi = 10, col="orange")
persp(x,y,z,theta = -25, phi = 10, col="orange")
persp(x,y,z,theta = -25, phi = 25, col="orange")
